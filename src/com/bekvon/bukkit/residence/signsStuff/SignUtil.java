package com.bekvon.bukkit.residence.signsStuff;

import java.io.File;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TimeZone;
import java.util.concurrent.ConcurrentHashMap;

import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Location;
import org.bukkit.World;
import org.bukkit.block.Block;
import org.bukkit.block.Sign;
import org.bukkit.command.CommandSender;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.YamlConfiguration;

import net.Zrips.CMILib.Items.CMIMaterial;
import com.bekvon.bukkit.residence.CommentedYamlConfiguration;
import com.bekvon.bukkit.residence.Residence;
import com.bekvon.bukkit.residence.containers.lm;
import com.bekvon.bukkit.residence.economy.rent.RentedLand;
import com.bekvon.bukkit.residence.protection.ClaimedResidence;
import com.bekvon.bukkit.residence.utils.Utils;

public class SignUtil {

    private Residence plugin;
    public SignInfo Signs = new SignInfo();

    public SignUtil(Residence plugin) {
	this.plugin = plugin;
    }

    public SignInfo getSigns() {
	return Signs;
    }

    public int updateAllSigns() {
	ConcurrentHashMap<String, Signs> temp = new ConcurrentHashMap<String, Signs>();
	temp.putAll(Signs.GetAllSigns());
	for (Entry<String, Signs> one : temp.entrySet()) {
	    SignUpdate(one.getValue());
	}
	saveSigns();
	return temp.size();
    }

    // Sign file
    public void LoadSigns() {

	Signs.GetAllSigns().clear();
	File file = new File(plugin.getDataFolder(), "Signs.yml");
	YamlConfiguration f = YamlConfiguration.loadConfiguration(file);

	if (!f.isConfigurationSection("Signs"))
	    return;

	ConfigurationSection ConfCategory = f.getConfigurationSection("Signs");
	ArrayList<String> categoriesList = new ArrayList<String>(ConfCategory.getKeys(false));
	if (categoriesList.size() == 0)
	    return;
	for (String category : categoriesList) {
	    ConfigurationSection NameSection = ConfCategory.getConfigurationSection(category);
	    Signs newTemp = new Signs();

	    ClaimedResidence res = plugin.getResidenceManager().getByName(NameSection.contains("Residence") ? NameSection.getString("Residence") : NameSection.getString("Res"));

	    if (res == null)
		continue;

	    newTemp.setResidence(res);

	    if (NameSection.contains("World")) {
		World w = Bukkit.getWorld(NameSection.getString("World"));
		if (w == null)
		    continue;
		double x = NameSection.getDouble("X");
		double y = NameSection.getDouble("Y");
		double z = NameSection.getDouble("Z");
		Location loc = new Location(w, x, y, z);
		newTemp.setLocation(loc);
	    } else {
		Location loc = Utils.convertStringToLocation(NameSection.getString("Loc"));
		newTemp.setLocation(loc);
	    }

	    Signs.addSign(newTemp);
	}
	return;
    }

    // Signs save file
    public void saveSigns() {

	File f = new File(plugin.getDataFolder(), "Signs.yml");
	YamlConfiguration conf = YamlConfiguration.loadConfiguration(f);

	CommentedYamlConfiguration writer = new CommentedYamlConfiguration();
	conf.options().copyDefaults(true);

	writer.addComment("Signs", "DO NOT EDIT THIS FILE BY HAND!");

	if (!conf.isConfigurationSection("Signs"))
	    conf.createSection("Signs");

	int i = 0;
	for (Entry<String, Signs> one : new ConcurrentHashMap<String, Signs>(Signs.GetAllSigns()).entrySet()) {
	    Signs s = one.getValue();
	    ++i;
	    String path = "Signs." + i;
	    writer.set(path + ".Res", s.getResidence().getName());
	    writer.set(path + ".Loc", Utils.convertLocToStringTiny(s.getLocation()));
	}

	try {
	    writer.save(f);
	} catch (IOException e) {
	    e.printStackTrace();
	}
	return;
    }

    public Signs getSignFromLoc(Location loc) {
	return this.getSigns().getResSign(loc);
    }

    public void CheckSign(final ClaimedResidence res, int time) {
	Bukkit.getServer().getScheduler().scheduleSyncDelayedTask(this.plugin, new Runnable() {
	    @Override
	    public void run() {
		CheckSign(res);
	    }
	}, time * 1L);
    }

    public void CheckSign(ClaimedResidence res) {
	for (Signs one : res.getSignsInResidence()) {
	    if (res != one.getResidence())
		continue;
	    this.SignUpdate(one);
	}
	saveSigns();
    }

    @Deprecated
    public void removeSign(String res) {
	if (res != null)
	    removeSign(plugin.getResidenceManager().getByName(res));
    }

    public void removeSign(ClaimedResidence res) {
	for (Signs one : res.getSignsInResidence()) {
	    if (res != one.getResidence())
		continue;
	    this.SignUpdate(one);
	}
    }

    public void updateSignResName(ClaimedResidence res) {
	for (Signs one : res.getSignsInResidence()) {
	    if (res != one.getResidence())
		continue;
	    this.SignUpdate(one);
	    saveSigns();
	    break;
	}
    }

    public boolean SignUpdate(Signs Sign) {

	ClaimedResidence res = Sign.getResidence();

	if (res == null)
	    return false;

	boolean ForSale = res.isForSell();
	boolean ForRent = res.isForRent();

	Location nloc = Sign.getLocation();

	if (nloc == null) {
	    Signs.removeSign(Sign);
	    res.getSignsInResidence().remove(Sign);
	    return false;
	}

	Block block = nloc.getBlock();

	if (!CMIMaterial.isSign(block.getType())) {
	    Signs.removeSign(Sign);
	    res.getSignsInResidence().remove(Sign);
	    return false;
	}

	Sign sign = (Sign) block.getState();

	String landName = res.getName();
	if (landName == null)
	    return false;
	if (!ForRent && !ForSale) {
	    String shortName = fixResName(landName);
	    String secondLine = null;
	    if (shortName.contains("~")) {
		String[] lines = fixDoubleResName(landName);
		shortName = lines[0];
		secondLine = lines[1];
	    }
	    sign.setLine(0, plugin.msg(lm.Sign_ResName, shortName));
	    if (secondLine != null)
		sign.setLine(1, plugin.msg(lm.Sign_ResName, secondLine));
	    sign.setLine(2, "");
	    sign.setLine(3, "");
	    sign.setLine(secondLine == null ? 1 : 2, plugin.msg(lm.Sign_Owner, res.getOwner()));
	    sign.update();

//	    block.breakNaturally();
//	    Signs.removeSign(Sign);
	    return true;
	}

	if (ForRent) {

	    boolean rented = res.isRented();

	    RentedLand rentedPlace = res.getRentedLand();
	    long time = 0L;
	    if (rentedPlace != null)
		time = rentedPlace.endTime;

	    SimpleDateFormat formatter = new SimpleDateFormat(plugin.msg(lm.Sign_DateFormat));
	    formatter.setTimeZone(TimeZone.getTimeZone(plugin.getConfigManager().getTimeZone()));
	    Calendar calendar = Calendar.getInstance();
	    calendar.setTimeInMillis(time);
	    String timeString = formatter.format(calendar.getTime());

	    String endDate = timeString;
	    if (time == 0L)
		endDate = "Unknown";

	    if (plugin.getRentManager().getRentedAutoRepeats(res))
		endDate = plugin.msg(lm.Sign_RentedAutorenewTrue, endDate);
	    else
		endDate = plugin.msg(lm.Sign_RentedAutorenewFalse, endDate);

	    String TopLine = rented ? plugin.msg(lm.Sign_RentedTopLine, endDate) : plugin.msg(lm.Sign_ForRentTopLine);
	    sign.setLine(0, TopLine);

	    String infoLine = plugin.msg(rented ? lm.Sign_RentedPriceLine : lm.Sign_ForRentPriceLine, plugin.getRentManager().getCostOfRent(res), plugin
		.getRentManager().getRentDays(res), plugin.getRentManager().getRentableRepeatable(res));

	    sign.setLine(1, infoLine);
	    String shortName = fixResName(landName);
	    sign.setLine(2, rented ? plugin.msg(lm.Sign_RentedResName, shortName)
		: plugin.msg(lm.Sign_RentedResName, shortName));
	    sign.setLine(3, rented ? plugin.msg(lm.Sign_RentedBottomLine, plugin.getRentManager().getRentingPlayer(landName))
		: plugin.msg(lm.Sign_ForRentBottomLine));
	    sign.update();
	}

	if (ForSale) {
	    String shortName = fixResName(landName);
	    String secondLine = null;
	    if (shortName.contains("~")) {
		String[] lines = fixDoubleResName(landName);
		shortName = lines[0];
		secondLine = lines[1];
	    }

	    sign.setLine(0, plugin.msg(lm.Sign_ForSaleTopLine));
	    String infoLine = plugin.msg(lm.Sign_ForSalePriceLine, res.getSellPrice());
	    sign.setLine(1, infoLine);
	    sign.setLine(2, plugin.msg(lm.Sign_RentedResName, shortName));

	    if (secondLine != null)
		sign.setLine(3, plugin.msg(lm.Sign_RentedResName, secondLine));
	    else
		sign.setLine(3, plugin.msg(lm.Sign_ForSaleBottom, res.getTotalSize()));
	    sign.update();
	}

	return true;
    }

    public void convertSigns(CommandSender sender) {
	File file = new File("plugins/ResidenceSigns/signs.yml");
	if (!file.exists()) {
	    sender.sendMessage(ChatColor.GOLD + "Can't find ResidenceSign file");
	    return;
	}
	YamlConfiguration conf = YamlConfiguration.loadConfiguration(file);

	if (!conf.contains("signs")) {
	    sender.sendMessage(ChatColor.GOLD + "Incorrect format of signs file");
	    return;
	}

	Set<String> sectionname = conf.getConfigurationSection("signs").getKeys(false);
	ConfigurationSection section = conf.getConfigurationSection("signs");

	long time = System.currentTimeMillis();

	int i = 0;
	for (String one : sectionname) {
	    Signs signs = new Signs();
	    String resname = section.getString(one + ".resName");

	    ClaimedResidence res = plugin.getResidenceManager().getByName(resname);

	    if (res == null)
		continue;

	    signs.setResidence(res);

	    List<String> loc = section.getStringList(one + ".loc");

	    if (loc.size() != 4)
		continue;

	    World world = Bukkit.getWorld(loc.get(0));
	    if (world == null)
		continue;

	    int x = 0;
	    int y = 0;
	    int z = 0;

	    try {
		x = Integer.parseInt(loc.get(1));
		y = Integer.parseInt(loc.get(2));
		z = Integer.parseInt(loc.get(3));
	    } catch (Exception ex) {
		continue;
	    }

	    signs.setLocation(new Location(world, x, y, z));

	    Signs s = this.getSigns().getResSign(signs.getLocation());
	    if (s == null)
		continue;

	    Location nloc = signs.getLocation();
	    Block block = nloc.getBlock();

	    if (!(block.getState() instanceof Sign))
		continue;

	    this.getSigns().addSign(signs);
	    this.SignUpdate(signs);
	    i++;
	}

	this.saveSigns();

	sender.sendMessage(ChatColor.GOLD + "" + i + ChatColor.YELLOW + " signs have being converted to new format! It took " + ChatColor.GOLD + (System
	    .currentTimeMillis() - time) + ChatColor.YELLOW + " ms!");
    }

    public String fixResName(String name) {
	if (name.length() > 15 && !name.contains("."))
	    name = "~" + name.substring(name.length() - 14);
	else if (name.length() > 15 && name.contains(".")) {
	    String[] splited = name.split("\\.");
	    name = "";
	    for (int i = 0; i < splited.length; i++) {
		String tempName = name + "." + splited[i];
		if (tempName.length() < 15)
		    name = tempName;
		else
		    name = "~" + tempName.substring(tempName.length() - 14);
	    }
	}
	return name;
    }

    public String[] fixDoubleResName(String name) {
	String SecondLine = name.substring(name.length() - 15);
	String FirstLine = name.replace(SecondLine, "");
	if (FirstLine.length() > 15 && !FirstLine.contains("."))
	    FirstLine = "~" + FirstLine.substring(name.length() - 14);
	else if (FirstLine.length() > 15 && FirstLine.contains(".")) {
	    String[] splited = FirstLine.split("\\.");
	    FirstLine = "";
	    for (int i = 0; i < splited.length; i++) {
		String tempName = FirstLine + "." + splited[i];
		if (tempName.length() < 15)
		    FirstLine = tempName;
		else
		    FirstLine = "~" + tempName.substring(tempName.length() - 14);
	    }
	}
	String[] lines = new String[2];
	lines[0] = FirstLine;
	lines[1] = SecondLine;
	return lines;
    }
}